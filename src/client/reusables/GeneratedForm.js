import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import CodeEditor from './CodeEditor';
import _ from 'lodash';
import axios from 'axios';
import { default as fromCamelCase } from '../utils/camelcase_convert';
import { default as gensig } from '../../lib/utils/gensig';

var FormBackground = styled.form`
  background-color: cadetblue;
  width: fit-content;
  margin: auto;
  text-align: left;
`;

var FormDiv = styled.div`
  padding: 8px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormInput = styled.input`
  border-radius: 8px;
  vertical-align: top;
  height: 16px;
  margin-top: 5px;
  font-family: sans-serif;
  font-size: 16px;
  padding: 5px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormHeader = styled.h2`
  text-align: center;
  font-family: sans-serif;
`;

var FormLabel = styled.label`
  color: white;
  padding-right: 4px;
  font-family: sans-serif;
  text-transform: uppercase;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormEnumInput = styled.select`
  font-family: sans-serif;
  font-size: 16px;
`;

var FormObjectInputLabel = styled.p`
  color: white;
  padding-right: 4px;
  font-family: sans-serif;
  text-transform: uppercase;
  margin: 8px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormSubmit = styled.input`
  font-family: sans-serif;
  text-transform: uppercase;
  margin: 8px;
  border-radius: 8px;
  font-size: 14px;
`;

var FormErrorMessage = styled.p`
  font-family: sans-serif;
  text-transform: uppercase;
  text-align: center;
`;

var FormSubmitButton = styled.button`
  font-size: 16px;
  font-family: sans-serif;
  text-transform: uppercase;
  padding: 8px;
  border-radius: 8px;
  margin: 8px;
`;

class GeneratedForm extends Component {
  static propTypes = {
    title: PropTypes.string.isRequired,
    params: PropTypes.objectOf(PropTypes.shape({
      label: PropTypes.string,
      type: PropTypes.oneOfType(
        [PropTypes.string, PropTypes.func]).isRequired,
      grammar: PropTypes.string,
      shape: PropTypes.oneOfType(
        [PropTypes.object, PropTypes.func]),
      value: PropTypes.oneOfType([PropTypes.string, PropTypes.object,
        PropTypes.array]),
      enumList: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.shape({
        value: PropTypes.string,
        text: PropTypes.string
      })), PropTypes.func]),
      maximum: PropTypes.number,
      minimum: PropTypes.number
    })).isRequired,
    successCallback: PropTypes.func,
    method: PropTypes.string.isRequired,
    formAction: PropTypes.string.isRequired,
    parentCallback: PropTypes.func,
    fileContent: PropTypes.string,
    redirectUrl: PropTypes.string
  };

  static defaultProps = {
    parentCallback: undefined,
    fileContent: 'fileContent',
    method: 'post'
  };

  constructor(props) {
    super(props);
    let values = {};
    for (let n in this.props.params) {
      _.set(values, n, _.get(this.props.params, n).value);
    }
    this.state = {
      values: values,
      errorMessage: ''
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleArrayRemove = this.handleArrayRemove.bind(this);
    this.handleArrayAdd = this.handleArrayAdd.bind(this);
    this.autoGeneratedInput = this.autoGeneratedInput.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  readFile(file) {
    let rdr = new FileReader();
    return new Promise((resolve, reject) => {
      rdr.onload = event => resolve(event.target.result);
      rdr.onerror = error => reject(error);
      rdr.readAsArrayBuffer(file);
    });
  }

  handleChange(param) {
    var self = this;
    return async function(event) {
      event.preventDefault();
      var newState = {
        values: self.state.values
      };

      _.set(newState.values, param, event.target.value);

      if (event.target.type === 'file') {
        var contents = await self.readFile(event.target.files[0]);
        var sixfour = Buffer.from(contents).toString('base64');
        _.set(newState.values, self.props.fileContent, sixfour);
      }

      self.setState(newState);
      if (self.props.parentCallback !== undefined)
        self.props.parentCallback(newState.values);
    }
  }

  handleArrayRemove(param, n) {
    var self = this;
    return function(event) {
      event.preventDefault();
      var newState = {
        values: self.state.values
      };
      newState.values[param].splice(n, 1);
      self.setState(newState);
    }
  }

  handleArrayAdd(param) {
    var self = this;
    return function(event) {
      event.preventDefault();
      var newState = {
          values: self.state.values
        }, toAdd = {};
      if (self.props.params[param].type === '[object]') {
        for (var key in self.props.params[param].shape) {
          toAdd[key] = '';
        }
      }
      else toAdd = '';
      newState.values[param].push(toAdd);
      self.setState(newState);
    }
  }

  autoGeneratedInput(param, iteration) {
    let params = this.props.params, values = this.state.values,
      handleChange = this.handleChange,
      handleArrayRemove = this.handleArrayRemove,
      handleArrayAdd = this.handleArrayAdd,
      paramObj = _.get(params,
        param.replace(/\.\$\.(\$\.)?/, '.shape.').replace(/\.\$$/, '')),
      valueParamKey = iteration !== undefined ?
        param.replace(/\.\$\.(\$\.)?/, `.${iteration.toString()}.`)
          .replace(/\.\$$/, `.${iteration.toString()}`) : param,
      valueObj = _.get(values, valueParamKey),
      paramSplit2 = param.split('.'),
      overallObj = paramSplit2.length > 1 ?
        values[paramSplit2[0]] && values[paramSplit2[0]][paramSplit2[1]] ||
        {} : values[param],
      label = (paramObj && paramObj.label ||
        fromCamelCase(param.indexOf('.') > -1 ?
          param.split('.') .slice(
            param.match(/\.[a-z]+$/) ? -1 : 0)[0] : param)),
      paramType = (paramObj && paramObj.type) || undefined,
      isHidden = (paramObj && paramObj.hidden) || false;

    if (typeof paramType === 'string') {
      var comp;

      // recursive case if array type
      if (paramType.match(/\[.+\]/) !== null && iteration === undefined) {
        comp = <div>
          <FormObjectInputLabel>
            {label}
          </FormObjectInputLabel>
          <FormSubmitButton onClick={handleArrayAdd(param)}>
            {'Add'}</FormSubmitButton>
          <FormDiv>
            {this.autoGeneratedInput(`${valueParamKey}`, 0)}
          </FormDiv>
          <FormSubmitButton
            onClick={(e) => handleArrayRemove(param, 0)(e)}>
            {'Remove'}</FormSubmitButton>
          {(valueObj && typeof valueObj === 'object' && valueObj.length > 0) ?
            (valueObj.slice(1).map((node, i) => <div>
              <FormDiv>
                {this.autoGeneratedInput(`${valueParamKey}`, i + 1)}
              </FormDiv>
              <FormSubmitButton
                onClick={(e) => handleArrayRemove(param, i + 1)(e)}>
                {'Remove'}</FormSubmitButton>
            </div>)) : null}
        </div>;
      } else {
        if (paramType.match(/enum/) !== null) {
          return <div>
            <FormLabel htmlFor={valueParamKey}>
              {label +
              (iteration !== undefined ? (` ${iteration + 1}`) : '')}
            </FormLabel>
            <br/>
            <FormEnumInput id={valueParamKey}
              name={valueParamKey} value={valueObj}
              onChange={(e) => {
                handleChange(valueParamKey)(e);
              }}>
              {paramObj.enumList.map(
                (node) => {
                  return <option value={node.value}>
                    {node.text}</option>;
                }
              )}
            </FormEnumInput>
          </div>;
        } else if (paramType.match(/object/) !== null) {
          var isArray = (paramType.match(/\[.+\]/)),
            innards = [];

          for (var k in (paramObj.shape)) {
            innards.push(
              this.autoGeneratedInput(
                isArray ? `${valueParamKey}.$.${k}` :
                  `${valueParamKey}.${k}`, iteration));
            innards.push(<br/>);
          }

          comp = <div>
            <FormObjectInputLabel>
              {label +
              (iteration !== undefined ? (` ${iteration + 1}`) : '')}
            </FormObjectInputLabel>
            <FormDiv>
              {innards}
            </FormDiv></div>;
        } else if (paramType.match(/text/) !== null) {
          comp = <div>
            <FormLabel htmlFor={valueParamKey} hidden={isHidden}>
              {label +
              (iteration !== undefined ? (` ${iteration + 1}`) : '')}
            </FormLabel>
            <br/>
            {paramObj.grammar ?
              <CodeEditor id={valueParamKey} name={valueParamKey}
                grammar={paramObj.grammar} value={valueObj}/> :
              ((paramObj.maximum && paramObj.maximum !== '') ?
                <FormInput maxLength={paramObj.maximum}
                  id={valueParamKey} name={valueParamKey}
                  hidden={isHidden} type={paramType.match(/[a-z]+/)[0]}
                  value={valueObj} onChange={(e) => {
                    handleChange(valueParamKey)(e);
                  }}/> :
                <FormInput
                  id={valueParamKey} name={valueParamKey}
                  hidden={isHidden} type={paramType.match(/[a-z]+/)[0]}
                  value={valueObj} onChange={(e) => {
                    handleChange(valueParamKey)(e);
                  }}/>)}</div>;
        } else {
          let inputBounds = {};
          for (let ke in paramObj) {
            if (['maximum', 'minimum'].includes(ke)) {
              if (paramObj[ke] !== '')
                inputBounds[ke.substring(0, 3)] = paramObj[ke];
            }
          }
          comp = <div><FormLabel htmlFor={valueParamKey} hidden={isHidden}>
            {label +
            (iteration !== undefined ? (` ${iteration + 1}`) : '')}
          </FormLabel><br/><FormInput {...paramObj}
            id={valueParamKey} name={valueParamKey} hidden={isHidden}
            type={paramType.match(/[a-z]+/)[0]}
            value={valueObj}
            onChange={(e) => {
              handleChange(valueParamKey)(e);
            }}/></div>;
        }
      }

      return comp;
    } else if (typeof paramType === 'function') {
      return <div>
        <FormLabel htmlFor={valueParamKey}>{label}</FormLabel>
        <br/>
        <FormInput id={valueParamKey} name={valueParamKey}
          type={paramType(overallObj)} value={valueObj}
          onChange={(e) => {
            handleChange(valueParamKey)(e);
          }}/>
      </div>;
    }
  }

  handleSubmit(event) {
    let self = this, requestBody = {};
    Array.prototype.slice.call(
      event.target.parentElement.elements, 0 , -1).forEach(
      (node) => { requestBody[node.id] = node.value; });
    let sig = gensig(requestBody);
    axios({ method: self.props.method,
      headers: {
        'Content-Type': 'application/json'
      },
      url: self.props.formAction,
      data: { ...requestBody, sig: sig },
      withCredentials: true
    }).then(function(response) {
      if (self.props.successCallback)
        self.props.successCallback(response);
      else if (self.props.redirectUrl)
        window.location.href = self.props.redirectUrl;
    }).catch(function (error) {
      self.setState({ errorMessage: error.message });
    });
  }

  render() {
    let params = this.props.params,
      autoGeneratedInput = this.autoGeneratedInput;

    return (
      <div>
        <FormHeader>{this.props.title}</FormHeader>
        {this.state.errorMessage ?
          <FormErrorMessage>
            {this.state.errorMessage}
          </FormErrorMessage> : null}
        <FormBackground onSubmit={(e) => e.preventDefault()}>
          {Object.keys(params).map((param, i) => {
            return <FormDiv key={param + i.toString()}>
              {autoGeneratedInput(param)}
            </FormDiv>;
          })}
          <FormSubmit type="submit" value="Submit"
            onClick={this.handleSubmit} />
        </FormBackground>
      </div>
    );
  }
}

export default GeneratedForm;
