import React, { Component } from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import CodeEditor from './CodeEditor';
import _ from 'lodash';
import axios from 'axios';
import { default as fromCamelCase } from '../utils/camelcase_convert';
import { default as gensig } from '../../lib/utils/gensig';

var FormBackground = styled.form`
  background-color: cadetblue;
  width: fit-content;
  margin: auto;
  text-align: left;
`;

var FormDiv = styled.div`
  padding: 8px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormInput = styled.input`
  border-radius: 8px;
  vertical-align: top;
  height: 16px;
  margin-top: 5px;
  font-family: sans-serif;
  font-size: 16px;
  padding: 5px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormHeader = styled.h2`
  text-align: center;
  font-family: sans-serif;
`;

var FormLabel = styled.label`
  color: white;
  padding-right: 4px;
  font-family: sans-serif;
  text-transform: uppercase;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormEnumInput = styled.select`
  font-family: sans-serif;
  font-size: 16px;
`;

var FormObjectInputLabel = styled.p`
  color: white;
  padding-right: 4px;
  font-family: sans-serif;
  text-transform: uppercase;
  margin: 8px;
  display: ${props => props.hidden ? 'none' : 'block'}
`;

var FormSubmit = styled.input`
  font-family: sans-serif;
  text-transform: uppercase;
  margin: 8px;
  border-radius: 8px;
  font-size: 14px;
`;

var FormErrorMessage = styled.p`
  font-family: sans-serif;
  text-transform: uppercase;
  text-align: center;
`;

var FormSubmitButton = styled.button`
  font-size: 16px;
  font-family: sans-serif;
  text-transform: uppercase;
  padding: 8px;
  border-radius: 8px;
  margin: 8px;
`;

class GeneratedForm extends Component {
  static propTypes = {
    title: PropTypes.string.isRequired,
    params: PropTypes.objectOf(PropTypes.shape({
      label: PropTypes.string,
      type: PropTypes.oneOfType(
        [PropTypes.string, PropTypes.func]).isRequired,
      grammar: PropTypes.string,
      shape: PropTypes.oneOfType(
        [PropTypes.object, PropTypes.func]),
      value: PropTypes.oneOfType([PropTypes.string, PropTypes.object,
        PropTypes.array]),
      enumList: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.shape({
        value: PropTypes.string,
        text: PropTypes.string
      })), PropTypes.func]),
      maximum: PropTypes.number,
      minimum: PropTypes.number
    })).isRequired,
    successCallback: PropTypes.func,
    method: PropTypes.string.isRequired,
    formAction: PropTypes.string.isRequired,
    parentCallback: PropTypes.func,
    fileContent: PropTypes.string,
    redirectUrl: PropTypes.string
  };

  static defaultProps = {
    parentCallback: undefined,
    fileContent: 'fileContent'
  };

  constructor(props) {
    super(props);
    let values = {};
    for (let n in this.props.params) {
      values[n] = this.props.params[n].value;
    }
    this.state = {
      values: values,
      errorMessage: ''
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleArrayRemove = this.handleArrayRemove.bind(this);
    this.handleArrayAdd = this.handleArrayAdd.bind(this);
    this.autoGeneratedInput = this.autoGeneratedInput.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  readFile(file) {
    let rdr = new FileReader();
    return new Promise((resolve, reject) => {
      rdr.onload = event => resolve(event.target.result);
      rdr.onerror = error => reject(error);
      rdr.readAsArrayBuffer(file);
    });
  }

  handleChange(param) {
    var self = this;
    return async function(event) {
      event.preventDefault();
      var newState = {
        values: self.state.values
      };

      _.set(newState.values, param, event.target.value);

      if (event.target.type === 'file') {
        var contents = await self.readFile(event.target.files[0]);
        var sixfour = Buffer.from(contents).toString('base64');
        _.set(newState.values, self.props.fileContent, sixfour);
      }

      self.setState(newState);
      if (self.props.parentCallback !== undefined)
        self.props.parentCallback(newState.values);
    }
  }

  handleArrayRemove(param, n) {
    var self = this;
    return function(event) {
      event.preventDefault();
      var newState = {
        values: self.state.values
      };
      newState.values[param].splice(n, 1);
      self.setState(newState);
    }
  }

  handleArrayAdd(param) {
    var self = this;
    return function(event) {
      event.preventDefault();
      var newState = {
          values: self.state.values
        }, toAdd = {};
      if (self.props.params[param].type === '[object]') {
        for (var key in self.props.params[param].shape) {
          toAdd[key] = '';
        }
      }
      else toAdd = '';
      newState.values[param].push(toAdd);
      self.setState(newState);
    }
  }

  autoGeneratedInput(param, iteration) {
    var params = this.props.params, values = this.state.values,
      handleChange = this.handleChange,
      handleArrayRemove = this.handleArrayRemove,
      handleArrayAdd = this.handleArrayAdd, paramSplit =
      param.replace(/\.([^\d]+)/g, '.shape.$1')
        .replace(/\.\d/g, '').split('.'),
      paramObj = _.get(params, paramSplit.join('.')),
      valueObj = _.get(values, param), paramSplit2 = param.split('.'),
      overallObj = paramSplit2.length > 1 ?
        values[paramSplit2[0]] && values[paramSplit2[0]][paramSplit2[1]] ||
        { } : values[param];

    var label = paramObj.label || fromCamelCase(param.split('.').slice(-1)[0]);

    var paramType = paramObj && paramObj.type || undefined, isHidden =
      paramObj.hidden || false;

    if (typeof paramType === 'string') {
      var comp;

      if (paramType.match(/\[.+\]/) !== null && iteration === undefined) {
        comp = [
          <FormObjectInputLabel>
            {label}
          </FormObjectInputLabel>,
          <FormSubmitButton onClick={handleArrayAdd(param)}>
            {'Add'}</FormSubmitButton>,
          <FormDiv>
            {this.autoGeneratedInput(param, 0)}
          </FormDiv>,
          <FormSubmitButton
            onClick={(e) => handleArrayRemove(param, 0)(e)}>
            {'Remove'}</FormSubmitButton>,
          (valueObj && valueObj.length > 0) ?
            (valueObj.slice(1).map((node, i) => <div>
              <FormDiv>
                {this.autoGeneratedInput(param, i + 1)}
              </FormDiv>
              <FormSubmitButton
                onClick={(e) => handleArrayRemove(param, i + 1)(e)}>
                {'Remove'}</FormSubmitButton>
            </div>)) : null];
      }

      else if (paramType.match(/enum/) !== null) {
        return [
          <FormLabel htmlFor={param}>
            {label +
              (iteration !== undefined ? (` ${  iteration + 1}`) : '')}
          </FormLabel>,
          <br />,
          <FormEnumInput id={param} name={param}
            value={valueObj} onChange={(e) => {
              handleChange(param)(e);
            }}>
            {paramObj.enumList.map(
              (node) => {
                return <option value={node.value}>
                  {node.text}</option>;
              }
            )}
          </FormEnumInput>
        ];
      }

      else if (paramType.match(/object/) !== null) {
        var innards = [];

        for (var k in (paramObj.shape)) {
          innards.push(this.autoGeneratedInput(`${param}` +
          `${iteration !== undefined ? `.${iteration}` : ''}` + `.${k}`,
          iteration));
          innards.push(<br />);
        }

        comp = <div>
          <FormObjectInputLabel>
            {label +
              (iteration !== undefined ? (` ${  iteration + 1}`) : '')}
          </FormObjectInputLabel>
          <FormDiv>
            {innards}
          </FormDiv></div>;
      }

      else {
        comp = [<FormLabel htmlFor={param} hidden={isHidden}>
          {label +
          (iteration !== undefined ? (` ${iteration + 1}`) : '')}
        </FormLabel>, <br/>];
        if (paramType.match(/number/) || paramType.match(/date/)) {
          let inputBounds = {};
          for (let ke in paramObj) {
            if (['maximum', 'minimum'].includes(ke)) {
              if (paramObj[ke] !== '')
                inputBounds[ke.substring(0, 3)] = paramObj[ke];
            }
          }

          comp.push(<FormInput {...paramObj}
            id={param} name={param} hidden={isHidden}
            type={paramType.match(/[a-z]+/)[0]} value={valueObj}
            onChange={(e) => { handleChange(param)(e); }}/>);
        } else if (paramObj.grammar) {
          comp.push(<CodeEditor id={param} name={param}
            grammar={paramObj.grammar} value={valueObj}/>);
        } else if (paramObj !== undefined) {
          let bounds = {};
          if (paramObj.maximum && paramObj.maximum !== '')
            bounds.maxLength = paramObj.maximum
          comp.push(<FormInput {...bounds} id={param} name={param}
            hidden={isHidden} type={paramType.match(/[a-z]+/)[0]}
            value={valueObj} onChange={(e) => {
              handleChange(param)(e);
            }}/>);
        }
      }
      return comp;
    }
    else if (typeof paramType === 'function') {
      return [<FormLabel htmlFor={param}>
        {label}</FormLabel>,
      <br />,
      <FormInput id={param} name={param}
        type={paramType(overallObj)} value={valueObj}
        onChange={(e) => { handleChange(param)(e); } }/>]
    }
  }

  handleSubmit(event) {
    let self = this, requestBody = {};
    event.preventDefault();
    Array.prototype.slice.call(event.target.elements, 0 , -1).forEach(
      (node) => { requestBody[node.id] = node.value; });
    let sig = gensig(requestBody);
    axios({ method: self.props.method,
      headers: {
        'Content-Type': 'application/json'
      },
      url: self.props.formAction,
      data: { ...requestBody, sig: sig },
      withCredentials: true
    }).then(function(response) {
      if (self.props.successCallback)
        self.props.successCallback(response);
      else if (self.props.redirectUrl)
        window.location.href = self.props.redirectUrl;
    }).catch(function (error) {
      self.setState({ errorMessage: error.message });
    });
  }

  render() {
    let params = this.props.params,
      autoGeneratedInput = this.autoGeneratedInput;

    return (
      <div>
        <FormHeader>{this.props.title}</FormHeader>
        {this.state.errorMessage ?
          <FormErrorMessage>
            {this.state.errorMessage}
          </FormErrorMessage> : null}
        <FormBackground action={this.props.formAction}
          method={this.props.method} onSubmit={this.handleSubmit}>
          {Object.keys(params).map((param, i) => {
            return <FormDiv key={param + i.toString()}>
              {autoGeneratedInput(param)}
            </FormDiv>;
          })}
          <FormSubmit type="submit" value="Submit" />
        </FormBackground>
      </div>
    );
  }
}

export default GeneratedForm;
